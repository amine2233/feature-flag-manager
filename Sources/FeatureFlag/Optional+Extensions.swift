import Foundation

// MARK: - Unwrap Type
protocol OptionalProtocol {
    // the metatype value for the wrapped type.
    static var wrappedType: Any.Type { get }
}

extension Optional: OptionalProtocol {
    static var wrappedType: Any.Type { return Wrapped.self }
}

public func wrappedTypeFromOptionalType(_ type: Any.Type) -> Any.Type? {
    (type as? OptionalProtocol.Type)?.wrappedType ?? type
}

extension Sequence where Element == Mirror.Child {
    typealias ConfigurableFeatureFlag = (label: String, value: FeatureFlagConfigurableProtocol)

    /// This function return all the properties from a sequence generated by
    /// Mirror of the object (`Mirror(reflecting: loadedCollection).children`).
    /// It will return only the list of `@Flag` `@FlagCollection` properties.
    ///
    /// - Returns: `[ConfigurableFeatureFlag]`
    internal func featureFlagsConfigurableProperties() -> [ConfigurableFeatureFlag] {
        var featureFlagsProps = [ConfigurableFeatureFlag]()
        for property in self {
            guard let label = property.label, let obj = property.value as? FeatureFlagConfigurableProtocol else {
                continue
            }

            let propertyName = (label.hasPrefix("_") ? String(label.dropFirst()) : label)
            featureFlagsProps.append( (label: propertyName, value: obj) )
        }

        return featureFlagsProps
    }

}
